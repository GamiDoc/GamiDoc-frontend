{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED; // Class DBCSCodec reads and initializes mapping tables.\n\n\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\"); // Load tables.\n\n  var mappingTable = codecOptions.table(); // Decode tables: MBCS -> Unicode.\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n\n  this.decodeTableSeq = []; // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]); // Load & create GB18030 tables when needed.\n\n\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n    // Add GB18030 common decode nodes.\n\n    var commonThirdByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n    var commonFourthByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0)); // Fill out the tree\n\n    var firstByteNode = this.decodeTables[0];\n\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\");\n        }\n\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue;\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\");\n          }\n\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;\n          }\n        }\n      }\n    }\n  }\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode; // Encode tables: Unicode -> DBCS.\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n\n  this.encodeTable = []; // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n\n  this.encodeTableSeq = []; // Some chars can be decoded, but need not be encoded.\n\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  } // Use decode trie to recursively fill out encode tables.\n\n  this._fillEncodeTable(0, 0, skipEncodeChars); // Add more encoding pairs when needed.\n\n\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder; // Decoder helpers\n\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n\n  for (; addr > 0; addr >>>= 8) bytes.push(addr & 0xFF);\n\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n\n  return node;\n};\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16); // Choose the decoding node where we'll write our chars.\n\n  var writeTable = this._getDecodeTrieNode(curAddr);\n\n  curAddr = curAddr & 0xFF; // Write all other elements of the chunk to the table.\n\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}; // Encoder helpers\n\n\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n\n  return this.encodeTable[high];\n};\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  var node;\n\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  } // Traverse the character tree, allocating new nodes as needed.\n\n\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  } // Set the leaf to given dbcsCode.\n\n\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  var hasValues = false;\n  var subNodeEmpty = {};\n\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode);\n\n      hasValues = true;\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode;\n\n      if (!subNodeEmpty[subNodeIdx]) {\n        // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.\n\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;else subNodeEmpty[subNodeIdx] = true;\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n\n      hasValues = true;\n    }\n  }\n\n  return hasValues;\n}; // == Encoder ==================================================================\n\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined; // Static data\n\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n      leadSurrogate = this.leadSurrogate,\n      seqObj = this.seqObj,\n      nextChar = -1,\n      i = 0,\n      j = 0;\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    } // 1. Handle surrogates.\n\n\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode; // Double lead surrogate found.\n\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n\n      leadSurrogate = -1;\n    } // 2. Convert uCode character.\n\n\n    var dbcsCode = UNASSIGNED;\n\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {// TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    } // 3. Write dbcsCode character.\n\n\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    } else {\n      newBuf[j++] = dbcsCode >>> 24;\n      newBuf[j++] = dbcsCode >>> 16 & 0xFF;\n      newBuf[j++] = dbcsCode >>> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n      j = 0;\n\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {// See todo above.\n    }\n\n    this.seqObj = undefined;\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n\n  return newBuf.slice(0, j);\n}; // Export for testing\n\n\nDBCSEncoder.prototype.findIdx = findIdx; // == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBytes = []; // Static data\n\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n      nodeIdx = this.nodeIdx,\n      prevBytes = this.prevBytes,\n      prevOffset = this.prevBytes.length,\n      seqStart = -this.prevBytes.length,\n      // idx of the start of current parsed sequence.\n  uCode;\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset]; // Lookup in current trie node.\n\n    var uCode = this.decodeTables[nodeIdx][curByte];\n\n    if (uCode >= 0) {// Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n      i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);\n      }\n\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte); // Write the character to buffer, handling higher planes using surrogate pair.\n\n\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 | uCode >> 10;\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 | uCode & 0x3FF;\n    }\n\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8; // Reset trie node.\n\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n\n  this.nodeIdx = nodeIdx;\n  this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n  return newBuf.slice(0, j).toString('ucs2');\n};\n\nDBCSDecoder.prototype.end = function () {\n  var ret = ''; // Try to parse all remaining chars.\n\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var bytesArr = this.prevBytes.slice(1); // Parse remaining as usual.\n\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    if (bytesArr.length > 0) ret += this.write(bytesArr);\n  }\n\n  this.prevBytes = [];\n  this.nodeIdx = 0;\n  return ret;\n}; // Binary search for GB18030. Returns largest i such that table[i] <= val.\n\n\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n      r = table.length;\n\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + (r - l + 1 >> 1);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n\n  return l;\n}","map":{"version":3,"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","gb18030","commonThirdByteNodeIdx","push","commonFourthByteNodeIdx","firstByteNode","secondByteNode","j","thirdByteNode","k","fourthByteNode","l","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","node","toString","chunk","curAddr","parseInt","writeTable","part","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","hasValues","subNodeEmpty","mbCode","subNodeIdx","newPrefix","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBytes","buf","prevOffset","seqStart","curByte","ptr","uCodeLead","concat","ret","bytesArr","r","mid"],"sources":["/home/carlobottaro/Documents/Università/gamification/node_modules/iconv-lite/encodings/dbcs-codec.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 common decode nodes.\n        var commonThirdByteNodeIdx = this.decodeTables.length;\n        this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n        var commonFourthByteNodeIdx = this.decodeTables.length;\n        this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n        // Fill out the tree\n        var firstByteNode = this.decodeTables[0];\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n            for (var j = 0x30; j <= 0x39; j++) {\n                if (secondByteNode[j] === UNASSIGNED) {\n                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n                } else if (secondByteNode[j] > NODE_START) {\n                    throw new Error(\"gb18030 decode tables conflict at byte 2\");\n                }\n\n                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n                for (var k = 0x81; k <= 0xFE; k++) {\n                    if (thirdByteNode[k] === UNASSIGNED) {\n                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n                        continue;\n                    } else if (thirdByteNode[k] > NODE_START) {\n                        throw new Error(\"gb18030 decode tables conflict at byte 3\");\n                    }\n\n                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n                    for (var l = 0x30; l <= 0x39; l++) {\n                        if (fourthByteNode[l] === UNASSIGNED)\n                            fourthByteNode[l] = GB18030_CODE;\n                    }\n                }\n            }\n        }\n    }\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    var hasValues = false;\n    var subNodeEmpty = {};\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0) {\n            this._setEncodeChar(uCode, mbCode);\n            hasValues = true;\n        } else if (uCode <= NODE_START) {\n            var subNodeIdx = NODE_START - uCode;\n            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).\n                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.\n                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))\n                    hasValues = true;\n                else\n                    subNodeEmpty[subNodeIdx] = true;\n            }\n        } else if (uCode <= SEQ_START) {\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n            hasValues = true;\n        }\n    }\n    return hasValues;\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else if (dbcsCode < 0x1000000) {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        } else {\n            newBuf[j++] = dbcsCode >>> 24;\n            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;\n            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBytes = [];\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,\n        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n        }\n        else if (uCode === GB18030_CODE) {\n            if (i >= 3) {\n                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);\n            } else {\n                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + \n                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + \n                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + \n                          (curByte-0x30);\n            }\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode >= 0x10000) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 | (uCode >> 10);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 | (uCode & 0x3FF);\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBytes = (seqStart >= 0)\n        ? Array.prototype.slice.call(buf, seqStart)\n        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBytes.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var bytesArr = this.prevBytes.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBytes = [];\n        this.nodeIdx = 0;\n        if (bytesArr.length > 0)\n            ret += this.write(bytesArr);\n    }\n\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + ((r-l+1) >> 1);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}