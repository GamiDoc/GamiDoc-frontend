{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\n\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\n\nvar fetch = require('cross-fetch');\n\nvar PNG = require('@react-pdf/png-js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\n\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\n\nvar fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);\n\nvar PNG__default = /*#__PURE__*/_interopDefaultLegacy(PNG);\n\nPNG__default[\"default\"].isValid = function (data) {\n  try {\n    return !!new PNG__default[\"default\"](data);\n  } catch (e) {\n    return false;\n  }\n}; // Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\n\nvar JPEG = function JPEG(data) {\n  this.data = null;\n  this.width = null;\n  this.height = null;\n  this.data = data;\n\n  if (data.readUInt16BE(0) !== 0xffd8) {\n    throw new Error('SOI not found in JPEG');\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    throw new Error('Invalid JPEG.');\n  }\n\n  pos += 3;\n  this.height = data.readUInt16BE(pos);\n  pos += 2;\n  this.width = data.readUInt16BE(pos);\n};\n\nJPEG.isValid = function (data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar createCache = function createCache(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? 100 : _ref$limit;\n\n  var cache = {};\n  var keys = [];\n  return {\n    get: function get(key) {\n      return cache[key];\n    },\n    set: function set(key, value) {\n      keys.push(key);\n\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n\n      cache[key] = value;\n    },\n    reset: function reset() {\n      cache = {};\n      keys = [];\n    },\n    length: function length() {\n      return keys.length;\n    }\n  };\n};\n\nvar IMAGE_CACHE = createCache({\n  limit: 30\n});\n\nvar fetchRemoteFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee(uri, options) {\n    var response, buffer;\n    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch__default[\"default\"](uri, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchRemoteFile(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isValidFormat = function isValidFormat(format) {\n  var lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nvar guessFormat = function guessFormat(buffer) {\n  var format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG__default[\"default\"].isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nvar isCompatibleBase64 = function isCompatibleBase64(_ref2) {\n  var uri = _ref2.uri;\n  return /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n};\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n\n    case 'png':\n      return new PNG__default[\"default\"](body);\n\n    default:\n      return null;\n  }\n}\n\nvar resolveBase64Image = function resolveBase64Image(_ref3) {\n  var uri = _ref3.uri;\n  var match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  var format = match[1];\n  var data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(\"Base64 image invalid format: \" + format);\n  }\n\n  return new Promise(function (resolve) {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nvar resolveImageFromData = function resolveImageFromData(src) {\n  if (src.data && src.format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(src.data, src.format));\n    });\n  }\n\n  throw new Error(\"Invalid data given for local file: \" + JSON.stringify(src));\n};\n\nvar resolveBufferImage = function resolveBufferImage(buffer) {\n  var format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(buffer, format));\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar getImageFormat = function getImageFormat(body) {\n  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;\n  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n  var extension = '';\n\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nvar resolveImageFromUrl = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee2(src) {\n    var uri, body, headers, _src$method, method, data, extension;\n\n    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? 'GET' : _src$method;\n            {\n              _context2.next = 7;\n              break;\n            }\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.next = 9;\n            return fetchRemoteFile(uri, {\n              body: body,\n              headers: headers,\n              method: method\n            });\n\n          case 9:\n            _context2.t0 = _context2.sent;\n\n          case 10:\n            data = _context2.t0;\n            extension = getImageFormat(data);\n            return _context2.abrupt(\"return\", getImage(data, extension));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveImageFromUrl(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar resolveImage = function resolveImage(src, _temp) {\n  var _ref5 = _temp === void 0 ? {} : _temp,\n      _ref5$cache = _ref5.cache,\n      cache = _ref5$cache === void 0 ? true : _ref5$cache;\n\n  var cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  var image;\n\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexports[\"default\"] = resolveImage;","map":{"version":3,"mappings":"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","names":["PNG","isValid","data","e","MARKERS","JPEG","width","height","readUInt16BE","Error","marker","pos","length","includes","Buffer","isBuffer","createCache","limit","cache","keys","get","key","set","value","push","shift","reset","IMAGE_CACHE","fetchRemoteFile","uri","options","_context","fetch","response","buffer","arrayBuffer","constructor","name","from","isValidFormat","lower","format","toLowerCase","guessFormat","isCompatibleBase64","test","getImage","body","extension","resolveBase64Image","match","exec","Promise","resolve","resolveImageFromData","src","JSON","stringify","resolveBufferImage","getImageFormat","isPng","isJpg","resolveImageFromUrl","headers","_src$method","method","_context2","resolveImage","cacheKey","toString","image"],"sources":["/home/carlobottaro/Documents/Università/gamification/node_modules/@react-pdf/image/src/png.js","/home/carlobottaro/Documents/Università/gamification/node_modules/@react-pdf/image/src/jpeg.js","/home/carlobottaro/Documents/Università/gamification/node_modules/@react-pdf/image/src/cache.js","/home/carlobottaro/Documents/Università/gamification/node_modules/@react-pdf/image/src/resolve.js"],"sourcesContent":["import PNG from '@react-pdf/png-js';\n\nPNG.isValid = function(data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default PNG;\n","// Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\nconst MARKERS = [\n  0xffc0,\n  0xffc1,\n  0xffc2,\n  0xffc3,\n  0xffc5,\n  0xffc6,\n  0xffc7,\n  0xffc8,\n  0xffc9,\n  0xffca,\n  0xffcb,\n  0xffcc,\n  0xffcd,\n  0xffce,\n  0xffcf,\n];\n\nclass JPEG {\n  data = null;\n\n  width = null;\n\n  height = null;\n\n  constructor(data) {\n    this.data = data;\n\n    if (data.readUInt16BE(0) !== 0xffd8) {\n      throw new Error('SOI not found in JPEG');\n    }\n\n    let marker;\n    let pos = 2;\n\n    while (pos < data.length) {\n      marker = data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw new Error('Invalid JPEG.');\n    }\n\n    pos += 3;\n    this.height = data.readUInt16BE(pos);\n\n    pos += 2;\n    this.width = data.readUInt16BE(pos);\n  }\n}\n\nJPEG.isValid = data => {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  let marker;\n  let pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default JPEG;\n","const createCache = ({ limit = 100 } = {}) => {\n  let cache = {};\n  let keys = [];\n\n  return {\n    get: key => cache[key],\n    set: (key, value) => {\n      keys.push(key);\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n      cache[key] = value;\n    },\n    reset: () => {\n      cache = {};\n      keys = [];\n    },\n    length: () => keys.length,\n  };\n};\n\nexport default createCache;\n","import fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport fetch from 'cross-fetch';\n\nimport PNG from './png';\nimport JPEG from './jpeg';\nimport createCache from './cache';\n\nexport const IMAGE_CACHE = createCache({ limit: 30 });\n\nconst getAbsoluteLocalPath = src => {\n  if (BROWSER) {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  const { protocol, auth, host, port, hostname, path: pathname } = url.parse(\n    src,\n  );\n  const absolutePath = path.resolve(pathname);\n  if ((protocol && protocol !== 'file:') || auth || host || port || hostname) {\n    return undefined;\n  }\n  return absolutePath;\n};\n\nconst fetchLocalFile = src =>\n  new Promise((resolve, reject) => {\n    try {\n      if (BROWSER) {\n        reject(new Error('Cannot fetch local file in this environemnt'));\n        return;\n      }\n      const absolutePath = getAbsoluteLocalPath(src);\n      if (!absolutePath) {\n        reject(new Error(`Cannot fetch non-local path: ${src}`));\n        return;\n      }\n      fs.readFile(absolutePath, (err, data) =>\n        err ? reject(err) : resolve(data),\n      );\n    } catch (err) {\n      reject(err);\n    }\n  });\n\nconst fetchRemoteFile = async (uri, options) => {\n  const response = await fetch(uri, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nconst isValidFormat = format => {\n  const lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nconst guessFormat = buffer => {\n  let format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nconst isCompatibleBase64 = ({ uri }) =>\n  /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n    case 'png':\n      return new PNG(body);\n    default:\n      return null;\n  }\n}\n\nconst resolveBase64Image = ({ uri }) => {\n  const match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  const format = match[1];\n  const data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(`Base64 image invalid format: ${format}`);\n  }\n\n  return new Promise(resolve => {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nconst resolveImageFromData = src => {\n  if (src.data && src.format) {\n    return new Promise(resolve => resolve(getImage(src.data, src.format)));\n  }\n\n  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);\n};\n\nconst resolveBufferImage = buffer => {\n  const format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(resolve => resolve(getImage(buffer, format)));\n  }\n\n  return Promise.resolve();\n};\n\nconst getImageFormat = body => {\n  const isPng =\n    body[0] === 137 &&\n    body[1] === 80 &&\n    body[2] === 78 &&\n    body[3] === 71 &&\n    body[4] === 13 &&\n    body[5] === 10 &&\n    body[6] === 26 &&\n    body[7] === 10;\n\n  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n\n  let extension = '';\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nconst resolveImageFromUrl = async src => {\n  const { uri, body, headers, method = 'GET' } = src;\n\n  const data =\n    !BROWSER && getAbsoluteLocalPath(uri)\n      ? await fetchLocalFile(uri)\n      : await fetchRemoteFile(uri, { body, headers, method });\n\n  const extension = getImageFormat(data);\n\n  return getImage(data, extension);\n};\n\nconst resolveImage = (src, { cache = true } = {}) => {\n  const cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  let image;\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexport default resolveImage;\n"]},"metadata":{},"sourceType":"script"}