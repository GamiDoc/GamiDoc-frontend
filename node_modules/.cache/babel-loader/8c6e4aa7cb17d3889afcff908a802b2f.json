{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n/* eslint-disable no-multi-assign */\n\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\nvar _default = getDistances;\nexports.default = _default;","map":{"version":3,"names":["exports","__esModule","default","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","gap","factors","total","priorities","unconstrained","_priority","j","length","f","sum","before","after","priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","Math","abs","p","distances","index","_f","next","dist","push","_default"],"sources":["/home/carlobottaro/Documents/UniversitÃ /gamification/node_modules/@react-pdf/textkit/lib/engines/justification/getDistances.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/* eslint-disable no-multi-assign */\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\nvar _default = getDistances;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}