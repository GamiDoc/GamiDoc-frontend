{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.fetchEmojis = exports.embedEmojis = exports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\n\n\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n      format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n          index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","default","exports","__esModule","fetchEmojis","embedEmojis","_extends2","_emojiRegex","_image","emojis","regex","reflect","promise","apply","arguments","then","v","e","makeFetchEmojiImage","_removeNoColor","x","getCodePoints","string","Array","from","filter","map","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","url","format","promises","match","_loop","loading","emojiUrl","fetchEmojiImage","push","uri","image","data","exec","fragments","result","i","length","fragment","lastIndex","_match","index","emojiSize","attributes","fontSize","chunk","slice","replace","String","fromCharCode","attachment","width","height","yOffset","Math","floor","_default"],"sources":["/home/carlobottaro/Documents/Universit√†/gamification/node_modules/@react-pdf/layout/lib/text/emoji.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.fetchEmojis = exports.embedEmojis = exports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n      format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n          index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}