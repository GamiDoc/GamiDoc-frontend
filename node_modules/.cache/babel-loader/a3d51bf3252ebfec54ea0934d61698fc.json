{"ast":null,"code":"import zlib from 'zlib';\n\nvar PNG = /*#__PURE__*/function () {\n  PNG.decode = function decode(path, fn) {\n    {\n      throw new Error('PNG.decode not available in browser build');\n    }\n  };\n\n  PNG.load = function load(path) {\n    {\n      throw new Error('PNG.load not available in browser build');\n    }\n  };\n\n  function PNG(data) {\n    var i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var chunkSize = this.readUInt32();\n      var section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = Buffer.from(this.imgData);\n          return;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  var _proto = PNG.prototype;\n\n  _proto.read = function read(bytes) {\n    var result = new Array(bytes);\n\n    for (var i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n\n    return result;\n  };\n\n  _proto.readUInt32 = function readUInt32() {\n    var b1 = this.data[this.pos++] << 24;\n    var b2 = this.data[this.pos++] << 16;\n    var b3 = this.data[this.pos++] << 8;\n    var b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  };\n\n  _proto.readUInt16 = function readUInt16() {\n    var b1 = this.data[this.pos++] << 8;\n    var b2 = this.data[this.pos++];\n    return b1 | b2;\n  };\n\n  _proto.decodePixels = function decodePixels(fn) {\n    var _this = this;\n\n    return zlib.inflate(this.imgData, function (err, data) {\n      if (err) throw err;\n      var pos = 0;\n      var width = _this.width,\n          height = _this.height;\n      var pixelBytes = _this.pixelBitlength / 8;\n      var pixels = Buffer.alloc(width * height * pixelBytes);\n\n      function pass(x0, y0, dx, dy, singlePass) {\n        if (singlePass === void 0) {\n          singlePass = false;\n        }\n\n        var w = Math.ceil((width - x0) / dx);\n        var h = Math.ceil((height - y0) / dy);\n        var scanlineLength = pixelBytes * w;\n        var buffer = singlePass ? pixels : Buffer.alloc(scanlineLength * h);\n        var row = 0;\n        var c = 0;\n\n        while (row < h && pos < data.length) {\n          var byte;\n          var col;\n          var i;\n          var left;\n          var upper;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth;\n                var upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n          }\n\n          if (!singlePass) {\n            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            var bufferPos = row * scanlineLength;\n\n            for (i = 0; i < w; i++) {\n              for (var j = 0; j < pixelBytes; j++) {\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              }\n\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (_this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  };\n\n  _proto.decodePalette = function decodePalette() {\n    var palette = this.palette;\n    var length = palette.length;\n    var transparency = this.transparency.indexed || [];\n    var ret = Buffer.alloc(transparency.length + length);\n    var pos = 0;\n    var c = 0;\n\n    for (var i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  };\n\n  _proto.copyToImageData = function copyToImageData(imageData, pixels) {\n    var j;\n    var k;\n    var colors = this.colors;\n    var palette = null;\n    var alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    var data = imageData.data || imageData;\n    var length = data.length;\n    var input = palette || pixels;\n    var i = j = 0;\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        var v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  };\n\n  _proto.decode = function decode(fn) {\n    var _this2 = this;\n\n    var ret = Buffer.alloc(this.width * this.height * 4);\n    return this.decodePixels(function (pixels) {\n      _this2.copyToImageData(ret, pixels);\n\n      return fn(ret);\n    });\n  };\n\n  return PNG;\n}();\n\nexport { PNG as default };","map":{"version":3,"names":["zlib","PNG","decode","path","fn","Error","load","data","i","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","from","_proto","prototype","bytes","result","Array","b1","b2","b3","b4","readUInt16","decodePixels","_this","inflate","err","pixelBytes","pixels","alloc","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","decodePalette","ret","copyToImageData","imageData","k","alpha","_decodedPalette","input","v","_this2","default"],"sources":["/home/carlobottaro/Documents/UniversitÃ /gamification/node_modules/@react-pdf/png-js/lib/png-js.browser.es.js"],"sourcesContent":["import zlib from 'zlib';\n\nvar PNG = /*#__PURE__*/function () {\n  PNG.decode = function decode(path, fn) {\n    {\n      throw new Error('PNG.decode not available in browser build');\n    }\n  };\n\n  PNG.load = function load(path) {\n    {\n      throw new Error('PNG.load not available in browser build');\n    }\n  };\n\n  function PNG(data) {\n    var i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var chunkSize = this.readUInt32();\n      var section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = Buffer.from(this.imgData);\n          return;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  var _proto = PNG.prototype;\n\n  _proto.read = function read(bytes) {\n    var result = new Array(bytes);\n\n    for (var i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n\n    return result;\n  };\n\n  _proto.readUInt32 = function readUInt32() {\n    var b1 = this.data[this.pos++] << 24;\n    var b2 = this.data[this.pos++] << 16;\n    var b3 = this.data[this.pos++] << 8;\n    var b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  };\n\n  _proto.readUInt16 = function readUInt16() {\n    var b1 = this.data[this.pos++] << 8;\n    var b2 = this.data[this.pos++];\n    return b1 | b2;\n  };\n\n  _proto.decodePixels = function decodePixels(fn) {\n    var _this = this;\n\n    return zlib.inflate(this.imgData, function (err, data) {\n      if (err) throw err;\n      var pos = 0;\n      var width = _this.width,\n          height = _this.height;\n      var pixelBytes = _this.pixelBitlength / 8;\n      var pixels = Buffer.alloc(width * height * pixelBytes);\n\n      function pass(x0, y0, dx, dy, singlePass) {\n        if (singlePass === void 0) {\n          singlePass = false;\n        }\n\n        var w = Math.ceil((width - x0) / dx);\n        var h = Math.ceil((height - y0) / dy);\n        var scanlineLength = pixelBytes * w;\n        var buffer = singlePass ? pixels : Buffer.alloc(scanlineLength * h);\n        var row = 0;\n        var c = 0;\n\n        while (row < h && pos < data.length) {\n          var byte;\n          var col;\n          var i;\n          var left;\n          var upper;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth;\n                var upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n          }\n\n          if (!singlePass) {\n            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            var bufferPos = row * scanlineLength;\n\n            for (i = 0; i < w; i++) {\n              for (var j = 0; j < pixelBytes; j++) {\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              }\n\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (_this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  };\n\n  _proto.decodePalette = function decodePalette() {\n    var palette = this.palette;\n    var length = palette.length;\n    var transparency = this.transparency.indexed || [];\n    var ret = Buffer.alloc(transparency.length + length);\n    var pos = 0;\n    var c = 0;\n\n    for (var i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  };\n\n  _proto.copyToImageData = function copyToImageData(imageData, pixels) {\n    var j;\n    var k;\n    var colors = this.colors;\n    var palette = null;\n    var alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    var data = imageData.data || imageData;\n    var length = data.length;\n    var input = palette || pixels;\n    var i = j = 0;\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        var v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  };\n\n  _proto.decode = function decode(fn) {\n    var _this2 = this;\n\n    var ret = Buffer.alloc(this.width * this.height * 4);\n    return this.decodePixels(function (pixels) {\n      _this2.copyToImageData(ret, pixels);\n\n      return fn(ret);\n    });\n  };\n\n  return PNG;\n}();\n\nexport { PNG as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}