{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linkedList\"));\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\n\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new _linkedList.default();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new _linkedList.default.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new _linkedList.default.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\nvar _default = linebreak;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","default","exports","__esModule","_linkedList","linebreak","nodes","lines","settings","options","demerits","line","flagged","fitness","tolerance","activeNodes","sum","width","stretch","shrink","lineLengths","breaks","tmp","data","Infinity","breakpoint","position","ratio","fitnessClass","totals","previous","computeCost","start","end","active","currentLine","lineLength","length","type","infinity","computeSum","breakPointIndex","result","i","penalty","mainLoop","node","index","first","next","candidates","badness","tmpSum","currentClass","candidate","newNode","remove","Math","pow","abs","Node","insertBefore","push","undefined","forEach","size","reverse","glue","value","box","hyphenated","_default"],"sources":["/home/carlobottaro/Documents/Università/gamification/node_modules/@react-pdf/textkit/lib/engines/linebreaker/linebreak.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linkedList\"));\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new _linkedList.default();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new _linkedList.default.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new _linkedList.default.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\nvar _default = linebreak;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}