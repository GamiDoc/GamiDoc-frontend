{"ast":null,"code":"// Generated by CoffeeScript 1.7.1\n(function () {\n  var Struct,\n      VersionedStruct,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  Struct = require('./Struct');\n\n  VersionedStruct = function (_super) {\n    __extends(VersionedStruct, _super);\n\n    function VersionedStruct(type, versions) {\n      this.type = type;\n      this.versions = versions != null ? versions : {};\n\n      if (typeof this.type === 'string') {\n        this.versionGetter = new Function('parent', \"return parent.\" + this.type);\n        this.versionSetter = new Function('parent', 'version', \"return parent.\" + this.type + \" = version\");\n      }\n    }\n\n    VersionedStruct.prototype.decode = function (stream, parent, length) {\n      var fields, res, _ref;\n\n      if (length == null) {\n        length = 0;\n      }\n\n      res = this._setup(stream, parent, length);\n\n      if (typeof this.type === 'string') {\n        res.version = this.versionGetter(parent);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n\n      fields = this.versions[res.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + res.version);\n      }\n\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n\n      this._parseFields(stream, res, fields);\n\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n\n      return res;\n    };\n\n    VersionedStruct.prototype.size = function (val, parent, includePointers) {\n      var ctx, fields, key, size, type, _ref;\n\n      if (includePointers == null) {\n        includePointers = true;\n      }\n\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n\n      if (this.versions.header) {\n        _ref = this.versions.header;\n\n        for (key in _ref) {\n          type = _ref[key];\n\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n\n      fields = this.versions[val.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + val.version);\n      }\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    };\n\n    VersionedStruct.prototype.encode = function (stream, val, parent) {\n      var ctx, fields, i, key, ptr, type, _ref, _ref1;\n\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n\n      if (this.versions.header) {\n        _ref1 = this.versions.header;\n\n        for (key in _ref1) {\n          type = _ref1[key];\n\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n\n      fields = this.versions[val.version];\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      i = 0;\n\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return VersionedStruct;\n  }(Struct);\n\n  module.exports = VersionedStruct;\n}).call(this);","map":{"version":3,"names":["Struct","VersionedStruct","__hasProp","hasOwnProperty","__extends","child","parent","key","call","ctor","constructor","prototype","__super__","require","_super","type","versions","versionGetter","Function","versionSetter","decode","stream","length","fields","res","_ref","_setup","version","header","_parseFields","Error","process","size","val","includePointers","ctx","pointerSize","encode","i","ptr","_ref1","preEncode","pointers","startOffset","pos","pointerOffset","module","exports"],"sources":["/home/carlobottaro/Documents/UniversitÃ /gamification/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["// Generated by CoffeeScript 1.7.1\n(function() {\n  var Struct, VersionedStruct,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Struct = require('./Struct');\n\n  VersionedStruct = (function(_super) {\n    __extends(VersionedStruct, _super);\n\n    function VersionedStruct(type, versions) {\n      this.type = type;\n      this.versions = versions != null ? versions : {};\n      if (typeof this.type === 'string') {\n        this.versionGetter = new Function('parent', \"return parent.\" + this.type);\n        this.versionSetter = new Function('parent', 'version', \"return parent.\" + this.type + \" = version\");\n      }\n    }\n\n    VersionedStruct.prototype.decode = function(stream, parent, length) {\n      var fields, res, _ref;\n      if (length == null) {\n        length = 0;\n      }\n      res = this._setup(stream, parent, length);\n      if (typeof this.type === 'string') {\n        res.version = this.versionGetter(parent);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n      fields = this.versions[res.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + res.version);\n      }\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n      this._parseFields(stream, res, fields);\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n      return res;\n    };\n\n    VersionedStruct.prototype.size = function(val, parent, includePointers) {\n      var ctx, fields, key, size, type, _ref;\n      if (includePointers == null) {\n        includePointers = true;\n      }\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n      if (this.versions.header) {\n        _ref = this.versions.header;\n        for (key in _ref) {\n          type = _ref[key];\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \" + val.version);\n      }\n      for (key in fields) {\n        type = fields[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    };\n\n    VersionedStruct.prototype.encode = function(stream, val, parent) {\n      var ctx, fields, i, key, ptr, type, _ref, _ref1;\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n      if (this.versions.header) {\n        _ref1 = this.versions.header;\n        for (key in _ref1) {\n          type = _ref1[key];\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n      fields = this.versions[val.version];\n      for (key in fields) {\n        type = fields[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      i = 0;\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return VersionedStruct;\n\n  })(Struct);\n\n  module.exports = VersionedStruct;\n\n}).call(this);\n"],"mappings":"AAAA;AACA,CAAC,YAAW;EACV,IAAIA,MAAJ;EAAA,IAAYC,eAAZ;EAAA,IACEC,SAAS,GAAG,GAAGC,cADjB;EAAA,IAEEC,SAAS,GAAG,UAASC,KAAT,EAAgBC,MAAhB,EAAwB;IAAE,KAAK,IAAIC,GAAT,IAAgBD,MAAhB,EAAwB;MAAE,IAAIJ,SAAS,CAACM,IAAV,CAAeF,MAAf,EAAuBC,GAAvB,CAAJ,EAAiCF,KAAK,CAACE,GAAD,CAAL,GAAaD,MAAM,CAACC,GAAD,CAAnB;IAA2B;;IAAC,SAASE,IAAT,GAAgB;MAAE,KAAKC,WAAL,GAAmBL,KAAnB;IAA2B;;IAACI,IAAI,CAACE,SAAL,GAAiBL,MAAM,CAACK,SAAxB;IAAmCN,KAAK,CAACM,SAAN,GAAkB,IAAIF,IAAJ,EAAlB;IAA8BJ,KAAK,CAACO,SAAN,GAAkBN,MAAM,CAACK,SAAzB;IAAoC,OAAON,KAAP;EAAe,CAFjS;;EAIAL,MAAM,GAAGa,OAAO,CAAC,UAAD,CAAhB;;EAEAZ,eAAe,GAAI,UAASa,MAAT,EAAiB;IAClCV,SAAS,CAACH,eAAD,EAAkBa,MAAlB,CAAT;;IAEA,SAASb,eAAT,CAAyBc,IAAzB,EAA+BC,QAA/B,EAAyC;MACvC,KAAKD,IAAL,GAAYA,IAAZ;MACA,KAAKC,QAAL,GAAgBA,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8B,EAA9C;;MACA,IAAI,OAAO,KAAKD,IAAZ,KAAqB,QAAzB,EAAmC;QACjC,KAAKE,aAAL,GAAqB,IAAIC,QAAJ,CAAa,QAAb,EAAuB,mBAAmB,KAAKH,IAA/C,CAArB;QACA,KAAKI,aAAL,GAAqB,IAAID,QAAJ,CAAa,QAAb,EAAuB,SAAvB,EAAkC,mBAAmB,KAAKH,IAAxB,GAA+B,YAAjE,CAArB;MACD;IACF;;IAEDd,eAAe,CAACU,SAAhB,CAA0BS,MAA1B,GAAmC,UAASC,MAAT,EAAiBf,MAAjB,EAAyBgB,MAAzB,EAAiC;MAClE,IAAIC,MAAJ,EAAYC,GAAZ,EAAiBC,IAAjB;;MACA,IAAIH,MAAM,IAAI,IAAd,EAAoB;QAClBA,MAAM,GAAG,CAAT;MACD;;MACDE,GAAG,GAAG,KAAKE,MAAL,CAAYL,MAAZ,EAAoBf,MAApB,EAA4BgB,MAA5B,CAAN;;MACA,IAAI,OAAO,KAAKP,IAAZ,KAAqB,QAAzB,EAAmC;QACjCS,GAAG,CAACG,OAAJ,GAAc,KAAKV,aAAL,CAAmBX,MAAnB,CAAd;MACD,CAFD,MAEO;QACLkB,GAAG,CAACG,OAAJ,GAAc,KAAKZ,IAAL,CAAUK,MAAV,CAAiBC,MAAjB,CAAd;MACD;;MACD,IAAI,KAAKL,QAAL,CAAcY,MAAlB,EAA0B;QACxB,KAAKC,YAAL,CAAkBR,MAAlB,EAA0BG,GAA1B,EAA+B,KAAKR,QAAL,CAAcY,MAA7C;MACD;;MACDL,MAAM,GAAG,KAAKP,QAAL,CAAcQ,GAAG,CAACG,OAAlB,CAAT;;MACA,IAAIJ,MAAM,IAAI,IAAd,EAAoB;QAClB,MAAM,IAAIO,KAAJ,CAAU,qBAAqBN,GAAG,CAACG,OAAnC,CAAN;MACD;;MACD,IAAIJ,MAAM,YAAYtB,eAAtB,EAAuC;QACrC,OAAOsB,MAAM,CAACH,MAAP,CAAcC,MAAd,EAAsBf,MAAtB,CAAP;MACD;;MACD,KAAKuB,YAAL,CAAkBR,MAAlB,EAA0BG,GAA1B,EAA+BD,MAA/B;;MACA,IAAI,CAACE,IAAI,GAAG,KAAKM,OAAb,KAAyB,IAA7B,EAAmC;QACjCN,IAAI,CAACjB,IAAL,CAAUgB,GAAV,EAAeH,MAAf;MACD;;MACD,OAAOG,GAAP;IACD,CA1BD;;IA4BAvB,eAAe,CAACU,SAAhB,CAA0BqB,IAA1B,GAAiC,UAASC,GAAT,EAAc3B,MAAd,EAAsB4B,eAAtB,EAAuC;MACtE,IAAIC,GAAJ,EAASZ,MAAT,EAAiBhB,GAAjB,EAAsByB,IAAtB,EAA4BjB,IAA5B,EAAkCU,IAAlC;;MACA,IAAIS,eAAe,IAAI,IAAvB,EAA6B;QAC3BA,eAAe,GAAG,IAAlB;MACD;;MACD,IAAI,CAACD,GAAL,EAAU;QACR,MAAM,IAAIH,KAAJ,CAAU,kBAAV,CAAN;MACD;;MACDK,GAAG,GAAG;QACJ7B,MAAM,EAAEA,MADJ;QAEJ2B,GAAG,EAAEA,GAFD;QAGJG,WAAW,EAAE;MAHT,CAAN;MAKAJ,IAAI,GAAG,CAAP;;MACA,IAAI,OAAO,KAAKjB,IAAZ,KAAqB,QAAzB,EAAmC;QACjCiB,IAAI,IAAI,KAAKjB,IAAL,CAAUiB,IAAV,CAAeC,GAAG,CAACN,OAAnB,EAA4BQ,GAA5B,CAAR;MACD;;MACD,IAAI,KAAKnB,QAAL,CAAcY,MAAlB,EAA0B;QACxBH,IAAI,GAAG,KAAKT,QAAL,CAAcY,MAArB;;QACA,KAAKrB,GAAL,IAAYkB,IAAZ,EAAkB;UAChBV,IAAI,GAAGU,IAAI,CAAClB,GAAD,CAAX;;UACA,IAAIQ,IAAI,CAACiB,IAAL,IAAa,IAAjB,EAAuB;YACrBA,IAAI,IAAIjB,IAAI,CAACiB,IAAL,CAAUC,GAAG,CAAC1B,GAAD,CAAb,EAAoB4B,GAApB,CAAR;UACD;QACF;MACF;;MACDZ,MAAM,GAAG,KAAKP,QAAL,CAAciB,GAAG,CAACN,OAAlB,CAAT;;MACA,IAAIJ,MAAM,IAAI,IAAd,EAAoB;QAClB,MAAM,IAAIO,KAAJ,CAAU,qBAAqBG,GAAG,CAACN,OAAnC,CAAN;MACD;;MACD,KAAKpB,GAAL,IAAYgB,MAAZ,EAAoB;QAClBR,IAAI,GAAGQ,MAAM,CAAChB,GAAD,CAAb;;QACA,IAAIQ,IAAI,CAACiB,IAAL,IAAa,IAAjB,EAAuB;UACrBA,IAAI,IAAIjB,IAAI,CAACiB,IAAL,CAAUC,GAAG,CAAC1B,GAAD,CAAb,EAAoB4B,GAApB,CAAR;QACD;MACF;;MACD,IAAID,eAAJ,EAAqB;QACnBF,IAAI,IAAIG,GAAG,CAACC,WAAZ;MACD;;MACD,OAAOJ,IAAP;IACD,CAxCD;;IA0CA/B,eAAe,CAACU,SAAhB,CAA0B0B,MAA1B,GAAmC,UAAShB,MAAT,EAAiBY,GAAjB,EAAsB3B,MAAtB,EAA8B;MAC/D,IAAI6B,GAAJ,EAASZ,MAAT,EAAiBe,CAAjB,EAAoB/B,GAApB,EAAyBgC,GAAzB,EAA8BxB,IAA9B,EAAoCU,IAApC,EAA0Ce,KAA1C;;MACA,IAAI,CAACf,IAAI,GAAG,KAAKgB,SAAb,KAA2B,IAA/B,EAAqC;QACnChB,IAAI,CAACjB,IAAL,CAAUyB,GAAV,EAAeZ,MAAf;MACD;;MACDc,GAAG,GAAG;QACJO,QAAQ,EAAE,EADN;QAEJC,WAAW,EAAEtB,MAAM,CAACuB,GAFhB;QAGJtC,MAAM,EAAEA,MAHJ;QAIJ2B,GAAG,EAAEA,GAJD;QAKJG,WAAW,EAAE;MALT,CAAN;MAOAD,GAAG,CAACU,aAAJ,GAAoBxB,MAAM,CAACuB,GAAP,GAAa,KAAKZ,IAAL,CAAUC,GAAV,EAAeE,GAAf,EAAoB,KAApB,CAAjC;;MACA,IAAI,OAAO,KAAKpB,IAAZ,KAAqB,QAAzB,EAAmC;QACjC,KAAKA,IAAL,CAAUsB,MAAV,CAAiBhB,MAAjB,EAAyBY,GAAG,CAACN,OAA7B;MACD;;MACD,IAAI,KAAKX,QAAL,CAAcY,MAAlB,EAA0B;QACxBY,KAAK,GAAG,KAAKxB,QAAL,CAAcY,MAAtB;;QACA,KAAKrB,GAAL,IAAYiC,KAAZ,EAAmB;UACjBzB,IAAI,GAAGyB,KAAK,CAACjC,GAAD,CAAZ;;UACA,IAAIQ,IAAI,CAACsB,MAAL,IAAe,IAAnB,EAAyB;YACvBtB,IAAI,CAACsB,MAAL,CAAYhB,MAAZ,EAAoBY,GAAG,CAAC1B,GAAD,CAAvB,EAA8B4B,GAA9B;UACD;QACF;MACF;;MACDZ,MAAM,GAAG,KAAKP,QAAL,CAAciB,GAAG,CAACN,OAAlB,CAAT;;MACA,KAAKpB,GAAL,IAAYgB,MAAZ,EAAoB;QAClBR,IAAI,GAAGQ,MAAM,CAAChB,GAAD,CAAb;;QACA,IAAIQ,IAAI,CAACsB,MAAL,IAAe,IAAnB,EAAyB;UACvBtB,IAAI,CAACsB,MAAL,CAAYhB,MAAZ,EAAoBY,GAAG,CAAC1B,GAAD,CAAvB,EAA8B4B,GAA9B;QACD;MACF;;MACDG,CAAC,GAAG,CAAJ;;MACA,OAAOA,CAAC,GAAGH,GAAG,CAACO,QAAJ,CAAapB,MAAxB,EAAgC;QAC9BiB,GAAG,GAAGJ,GAAG,CAACO,QAAJ,CAAaJ,CAAC,EAAd,CAAN;QACAC,GAAG,CAACxB,IAAJ,CAASsB,MAAT,CAAgBhB,MAAhB,EAAwBkB,GAAG,CAACN,GAA5B,EAAiCM,GAAG,CAACjC,MAArC;MACD;IACF,CArCD;;IAuCA,OAAOL,eAAP;EAED,CA3HiB,CA2HfD,MA3He,CAAlB;;EA6HA8C,MAAM,CAACC,OAAP,GAAiB9C,eAAjB;AAED,CAtID,EAsIGO,IAtIH,CAsIQ,IAtIR"},"metadata":{},"sourceType":"script"}